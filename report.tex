\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}

\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{Applying Design by Contract to \\ Java ArrayList Data Structure}

\author{Aldo Gabriele Di Rosa, Brenda Ruiz \\ \& Jacopo Fidacaro}

\date{\today}

\begin{document}
\maketitle

\section{Selection Process}

The selected project for implementing Design by Contract was the ArrayList and the Vector classes from Java Collections. We picked these two data structures given that their behaviour can be modelled by implementing Contracts and also because we are familiar with them. Initially, we thought about working with bachelor projects but decided not to work with them because they didn't have as many interfaces to work with. Then, we considered using a Java library but we realized we first had to invest a lot of time getting familiar with it and trying to understand how to implement contracts to them. Therefore, we developed our project using ArrayList and Vector.


\section{Contract Implementation}

First, we implemented an Interface "ListContract" which defines the ArrayList methods and where the each of the Contracts were implemented. Then, we created a class "ContractedArrayList" which implements our interface each of its methods. We created the analogous Interface and Class for the Vector, called VectorContract and ContractedVector respectively. \par
The approach followed for the implementation of the Contracts was first reading the class documentation for each method to understand and determine each one of the preconditions and postconditions. 
One of the challenges we faced during the implementation was understanding how to properly use the jSicko library. One obstacle we faced was understanding to name all variables with the same name so the library could parse them correctly. Also, in some cases, jSicko would produce errors which were difficult to understand what flaw they were pointing out and sometimes seemed arbitrary. (maybe add something more)

\section{Contracts Overview}

Overall, the preconditions we created require the parameters to be valid, for example, an index within the given size or the parameter was not null. For postconditions we ensured the appropiate changes were to the list and vector, such as changes in size and ensuring the list contains all elements after adding a Collection to it.
The contracts we implemented for both classes were similar, given that they are both classes from Java Collections and have similar behavior. 
For the ArrayList class, a total of 16 Contracts and one Invariant were implemented (shown on Table 1). For the Vector class, 9 contracts were implemented (Table 2). 
\begin{itemize}
 \item Invariant: nonNegativeSize. Ensures the size of the list is always equal or greater than 0. This invariant was used for both classes.
\end{itemize}

\begin{table}[h!]
\begin{tabular}{|l|l|l|}
	\hline
	\textbf{Method}                     & \textbf{Precondition}        & \textbf{Postcondition} \\ \hline
	add(E e)                            & sizeIncreases                &                        \\ \hline
	add(int index, E element)           & indexInRange                 & sizeIncreases          \\ \hline
	get(int index)                      & indexInRange                 &                        \\ \hline
	remove(Object o)                    &                              & sizeDoesNotIncrease    \\ \hline
	remove(int index)                   & indexInRange                 & sizeDecreases          \\ \hline
	addAll(Collection c)                &                              & containsAll            \\ \hline
	addAll(int index, Collection c)     & indexInRange                 &                        \\ \hline
	removeAll(Collection c)             & collectionNotNull            &                        \\ \hline
	retainAll(Collection c)             & collectionNotNull            &                        \\ \hline
	clear()                             & listEmpty                    &                        \\ \hline
	set(int index, E element)           & indexInRange                 &                        \\ \hline
	indexOf(Object o)                   & equalObjectAtFirstOccurrence &                        \\ \hline
	lastIndexOf(Object o)               & equalObjectAtLastPosition    &                        \\ \hline
	subList(int fromIndex, int toIndex) & indexesInRange               &                        \\ \hline
	toArray(E[] a)                  & arrayNotNull                 &                        \\ \hline
	\end{tabular}
	\caption{ArrayList Contracts}
	\label{table:1}
	\end{table}
	
	\begin{table}[h!]
	\begin{tabular}{|l|l|l|}
	\hline
	\textbf{Method}                      & \textbf{Precondition}        & \textbf{Postcondition} \\ \hline
	addElement(E obj)                         & sizeIncreases           &                        \\ \hline
	elementAt(int index)                      & indexWithinBounds                 &                        \\ \hline
	removeElementAt(int index)         & indexWithinBounds                 &       \\ \hline
	indexOf(Object o, int index)          &  nonNegativeIndex      & sizeStaysTheSame   \\ \hline
	lastElement()    							  & nonEmptyVector         &                                    \\ \hline
	firstElement()             				  & nonEmptyVector         &                         		      \\ \hline
	removeAllElements()                             & emptyVector                    &                        \\ \hline
	removeIf(Predicate<? super E> filter)          & filterNotNull &                                    \\ \hline
	lastIndexOf(Object o, int index)               & indexWithinBounds    &      sizeStaysTheSame   \\ \hline
\end{tabular}
\caption{Vector Contracts}
	\label{table:2}
\end{table}

\section{Testing Outcomes}
From our tests we were able to verify our preconditions worked properly. (?)

\section{Applicability to Other Projects}
Naturally, the contracts we implemented could be applied for other collections, applying minor changes to fit each of their structures. They could also be useful for applications where these kinds of data structures are used. 

\section{Conclusions}


\end{document}